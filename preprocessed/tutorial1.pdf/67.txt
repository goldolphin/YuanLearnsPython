【PG】4.1　改变类型　　 41

是吗？怎么会发生这种事情？卡特，我想肯定是你的计算机发疯了！
当然这只是开玩笑。 实际上， 这个问题有一个解释， 你可以看看下面的“ 到底
怎么回事？” 。

【PG】到底怎么回事？

还记得我们说过计算机在内部都使用二进制吧？ 对，
Python存储的所有数都是作为二进制存储的 。对 于0.1
和0.2之和 ，Python会用足够多的二进制位（比特）创
建一个浮点数 （小 数）来保证 15个小数位。 不过这
个二进制数并不完全等于 0.3 ，它只是相当相当接近。
（在这里，误 差是 0.000000000000004。 ） 这个差称为
舍入误差（roundoff  error ） 。

在交互模式中键入 0.1+0.2这 个表达式时，
Python会显示它存储的原始数值 ，包 括所有的小数
位。使用print时，你会得到期望的结果， 因为print更聪明一点， 它很
清楚要四舍五入显示 0.3 。
这就像问一个人时间 。他 可能会说“12 点44分53秒”。不过大多数人
都只是说 “差 一刻一点 ”，因为他们知道你不需要那么精确。 所有计算机语
言中浮点数都存在舍入误差 。对 于不同的计算机或者不同的语言来说， 你
得到的正确的位数可能有所不同 ，不 过都会使用同样的基本方法来存储浮
点数。
通常舍入误差都很小，所以不需要担心这些误差。

【PG】下面再试试另一个转换：
>>> e = 54.99
>>> f = int(e)
>>> print e
54.99
>>> print f
54

尽管 54.99与55很接近， 但是得到的整数仍然是 54。int()函数总是下取整。
它不会给你最接近的整数， 而 是会给出下一个最小的整数。 实际上int()函数就是
去掉小数部分。
如果想得到最接近的整数，也有一个办法。这个办法到第 21章再告诉你 。

图灵社区会员 FreeLink 专享 尊重版权